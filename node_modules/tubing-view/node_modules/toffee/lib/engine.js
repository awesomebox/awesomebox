// Generated by CoffeeScript 1.6.3
(function() {
  var MAX_CACHED_SANDBOXES, Pool, engine, fs, path, sandboxCons, states, tweakables, util, utils, view, vm, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  view = require('./view').view;

  _ref = require('./consts'), states = _ref.states, tweakables = _ref.tweakables;

  Pool = require('./pool').Pool;

  utils = require('./utils');

  fs = require('fs');

  path = require('path');

  util = require('util');

  vm = require('vm');

  MAX_CACHED_SANDBOXES = 100;

  sandboxCons = function() {
    return vm.createContext({});
  };

  engine = (function() {
    function engine(options) {
      this._fn_partial = __bind(this._fn_partial, this);
      this._fn_snippet = __bind(this._fn_snippet, this);
      this._fn_load = __bind(this._fn_load, this);
      this._inlineInclude = __bind(this._inlineInclude, this);
      this.run = __bind(this.run, this);
      this.render = __bind(this.render, this);
      options = options || {};
      this.verbose = options.verbose || false;
      this.minimize = options.minimize || false;
      this.pool = new Pool(sandboxCons, options.poolSize || MAX_CACHED_SANDBOXES);
      this.prettyPrintErrors = options.prettyPrintErrors != null ? options.prettyPrintErrors : true;
      this.prettyLogErrors = options.prettyLogErrors != null ? options.prettyLogErrors : true;
      this.autoEscape = options.autoEscape != null ? options.autoEscape : true;
      this.additionalErrorHandler = options.additionalErrorHandler || null;
      this.viewCache = {};
      this.fsErrorCache = {};
      this.filenameCache = {};
    }

    engine.prototype._log = function(o) {
      var _ref1;
      if (this.verbose) {
        if ((_ref1 = typeof o) === "string" || _ref1 === "number" || _ref1 === "boolean") {
          return console.log("toffee: " + o);
        } else {
          return console.log("toffee: " + (util.inspect(o)));
        }
      }
    };

    engine.prototype.normalizeFilename = function(dir, filename) {
      var cache, normalized;
      cache = this.filenameCache[dir];
      if (cache == null) {
        this.filenameCache[dir] = {};
        cache = {};
      }
      normalized = cache[filename];
      if (normalized == null) {
        normalized = path.normalize(path.resolve(dir, filename));
        this.filenameCache[dir][filename] = normalized;
      }
      return normalized;
    };

    engine.prototype.render = function(filename, options, cb) {
      return this.run(filename, options, cb);
    };

    engine.prototype.run = function(filename, options, cb) {
      /*
      "options" contains the pub vars and may contain special items:
          layout:                  path to a template expecting a body var (express 2.x style, but for use with express 3.x)
          __toffee.dir:            path to look relative to
          __toffee.parent:         parent file
          __toffee.noInheritance:  if true, don't pass variables through unless explicitly passed
          __toffee.repress         if true, don't output anything; useful with including definition files with passback of vars
          __toffee.autoEscape:     if set as false, don't escape output of #{} vars by default
      */

      var err, k, layout_options, res, v, _ref1, _ref2, _ref3, _ref4;
      if (options.prettyPrintErrors == null) {
        options.prettyPrintErrors = this.prettyPrintErrors;
      }
      if (options.prettyLogErrors == null) {
        options.prettyLogErrors = this.prettyLogErrors;
      }
      if (options.additionalErrorHandler == null) {
        options.additionalErrorHandler = this.additionalErrorHandler;
      }
      if (options.autoEscape == null) {
        options.autoEscape = this.autoEscape;
      }
      if (options != null ? options.layout : void 0) {
        layout_options = {};
        for (k in options) {
          v = options[k];
          if (k !== "layout") {
            layout_options[k] = v;
          }
        }
      }
      _ref1 = this.runSync(filename, options), err = _ref1[0], res = _ref1[1];
      if (err && this.prettyPrintErrors) {
        _ref2 = [null, err], err = _ref2[0], res = _ref2[1];
      }
      if ((!err) && (layout_options != null)) {
        layout_options.body = res;
        _ref3 = this.runSync(options.layout, layout_options), err = _ref3[0], res = _ref3[1];
        if (err && this.prettyPrintErrors) {
          _ref4 = [null, err], err = _ref4[0], res = _ref4[1];
        }
      }
      return cb(err, res);
    };

    engine.prototype.runSync = function(filename, options) {
      /*
      "options" the same as run() above
      */

      var ctx, err, realpath, res, start_time, v, _ref1, _ref2, _ref3,
        _this = this;
      start_time = Date.now();
      options = options || {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = options.__toffee.dir || process.cwd();
      realpath = this.normalizeFilename(options.__toffee.dir, filename);
      v = (this._viewCacheGet(realpath)) || (this._loadCacheAndMonitor(realpath, options));
      if (v) {
        if (this.fsErrorCache[realpath]) {
          _ref1 = ["Couldn't load " + realpath, null], err = _ref1[0], res = _ref1[1];
        } else {
          options.__toffee.parent = realpath;
          options.partial = options.partial || function(fname, lvars) {
            return _this._fn_partial(fname, lvars, realpath, options);
          };
          options.snippet = options.snippet || function(fname, lvars) {
            return _this._fn_snippet(fname, lvars, realpath, options);
          };
          options.load = options.load || function(fname, lvars) {
            return _this._fn_load(fname, lvars, realpath, options);
          };
          options.print = options.print || function(txt) {
            return _this._fn_print(txt, options);
          };
          if (options.console == null) {
            options.console = {
              log: console.log
            };
          }
          ctx = this.pool.get();
          _ref2 = v.run(options, ctx), err = _ref2[0], res = _ref2[1];
          this.pool.release(ctx);
        }
      } else {
        _ref3 = ["Couldn't load " + realpath, null], err = _ref3[0], res = _ref3[1];
      }
      this._log("" + realpath + " run in " + (Date.now() - start_time) + "ms");
      return [err, res];
    };

    engine.prototype._viewCacheGet = function(filename) {
      if (this.viewCache[filename] == null) {
        return null;
      } else if (this.fsErrorCache[filename] == null) {
        return this.viewCache[filename];
      } else if ((Date.now() - this.fsErrorCache[filename]) < tweakables.MISSING_FILE_RECHECK) {
        return this.viewCache[filename];
      } else {
        return null;
      }
    };

    engine.prototype._inlineInclude = function(filename, local_vars, parent_realpath, parent_options) {
      var err, k, noInheritance, options, repress, res, reserved, v, _i, _len, _ref1, _ref2, _ref3;
      options = local_vars || {};
      options.passback = {};
      options.__toffee = options.__toffee || {};
      options.__toffee.dir = path.dirname(parent_realpath);
      options.__toffee.parent = parent_realpath;
      noInheritance = options.__toffee.noInheritance;
      repress = options.__toffee.repress;
      reserved = {};
      _ref1 = ["passback", "load", "print", "partial", "snippet", "layout", "__toffee"];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        reserved[k] = true;
      }
      if (!noInheritance) {
        for (k in parent_options) {
          v = parent_options[k];
          if ((local_vars != null ? local_vars[k] : void 0) == null) {
            if (reserved[k] == null) {
              options[k] = v;
            }
          }
        }
      }
      _ref2 = this.runSync(filename, options), err = _ref2[0], res = _ref2[1];
      _ref3 = options.passback;
      for (k in _ref3) {
        v = _ref3[k];
        parent_options[k] = v;
      }
      return err || res;
    };

    engine.prototype._fn_load = function(fname, lvars, realpath, options) {
      lvars = lvars != null ? lvars : {};
      lvars.__toffee = lvars.__toffee || {};
      lvars.__toffee.repress = true;
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_snippet = function(fname, lvars, realpath, options) {
      lvars = lvars != null ? lvars : {};
      lvars.__toffee = lvars.__toffee || {};
      lvars.__toffee.noInheritance = true;
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_partial = function(fname, lvars, realpath, options) {
      return this._inlineInclude(fname, lvars, realpath, options);
    };

    engine.prototype._fn_print = function(txt, options) {
      if (options.__toffee.state === states.COFFEE) {
        options.__toffee.out.push(txt);
        return '';
      } else {
        return txt;
      }
    };

    engine.prototype._loadCacheAndMonitor = function(filename, options) {
      var e, previous_fs_err, txt, v, view_options, _ref1;
      previous_fs_err = this.fsErrorCache[filename] != null;
      try {
        txt = fs.readFileSync(filename, 'utf8');
        if (this.fsErrorCache[filename] != null) {
          delete this.fsErrorCache[filename];
        }
      } catch (_error) {
        e = _error;
        txt = "Error: Could not read " + filename;
        if (((_ref1 = options.__toffee) != null ? _ref1.parent : void 0) != null) {
          txt += " first requested in " + options.__toffee.parent;
        }
        this.fsErrorCache[filename] = Date.now();
      }
      if (this.fsErrorCache[filename] && previous_fs_err && this.viewCache[filename]) {
        return this.viewCache[filename];
      } else {
        view_options = this._generateViewOptions(filename);
        v = new view(txt, view_options);
        this.viewCache[filename] = v;
        this._monitorForChanges(filename, options);
        return v;
      }
    };

    engine.prototype._reloadFileInBkg = function(filename, options) {
      var _this = this;
      return fs.readFile(filename, 'utf8', function(err, txt) {
        var ctx, v, view_options, _ref1;
        if (err || (txt !== _this.viewCache[filename].txt)) {
          if (err) {
            _this.fsErrorCache[filename] = Date.now();
            txt = "Error: Could not read " + filename;
            if (((_ref1 = options.__toffee) != null ? _ref1.parent : void 0) != null) {
              txt += " requested in " + options.__toffee.parent;
            }
          }
          if (!(err && _this.viewCache[filename].fsError)) {
            view_options = _this._generateViewOptions(filename);
            ctx = _this.pool.get();
            view_options.ctx = ctx;
            view_options.cb = function(v) {
              _this._log("" + filename + " updated and ready");
              _this.viewCache[filename] = v;
              return _this.pool.release(ctx);
            };
            if (err) {
              view_options.fsError = true;
            }
            return v = new view(txt, view_options);
          }
        }
      });
    };

    engine.prototype._generateViewOptions = function(filename) {
      return {
        fileName: filename,
        verbose: this.verbose,
        prettyPrintErrors: this.prettyPrintErrors,
        prettyLogErrors: this.prettyLogErrors,
        autoEscape: this.autoEscape,
        additionalErrorHandler: this.additionalErrorHandler,
        minimize: this.minimize
      };
    };

    engine.prototype._monitorForChanges = function(filename, options) {
      /*
      we must continuously unwatch/rewatch because some editors/systems invoke a "rename"
      event and we'll end up following the wrong, old 'file' as a new one
      is dropped in its place.
      
      Files that are missing are ignored here because they get picked up by new calls to _loadCacheAndMonitor
      */

      var e, fsw,
        _this = this;
      if (this.fsErrorCache[filename] == null) {
        fsw = null;
        try {
          this._log("" + filename + " starting fs.watch()");
          return fsw = fs.watch(filename, {
            persistent: true
          }, function(change) {
            _this._log("" + filename + " closing fs.watch()");
            fsw.close();
            _this._monitorForChanges(filename, options);
            return _this._reloadFileInBkg(filename, options);
          });
        } catch (_error) {
          e = _error;
          this._log("fs.watch() failed for " + filename + "; settings fsErrorCache = true");
          return this.fsErrorCache[filename] = Date.now();
        }
      }
    };

    return engine;

  })();

  exports.engine = engine;

}).call(this);
