{
  "name": "qejs",
  "description": "Asyncronous Embedded JavaScript Templates with Q",
  "version": "3.0.5",
  "keywords": [
    "templating",
    "template",
    "engine",
    "promises",
    "Q",
    "EJS",
    "JavaScript",
    "async",
    "Asyncronous"
  ],
  "dependencies": {
    "q": "0.8.x"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "author": {
    "name": "JEPSO",
    "email": "contact@jepso.com",
    "url": "http://www.jepso.com"
  },
  "homepage": "http://substance.io/forbeslindesay/qejs",
  "repository": {
    "type": "git",
    "url": "git://github.com/jepso/QEJS.git"
  },
  "scripts": {
    "prepublish": "mocha",
    "test": "mocha -R spec"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/jepso/QEJS.png?branch=master)](http://travis-ci.org/jepso/QEJS)\r\n# Asyncronous Embedded JavaScript Templates with Q\r\n\r\n![QEJS](http://i.imgur.com/WRIlB.png)\r\n\r\nThis library impliments Embedded JavaScript with some asyncronous additions provided by Q.  It is broadly based on https://github.com/visionmedia/ejs and fully supports everything except filters.  For a full discussion of the reasoning behind this, see Features below.  The promises implimentation for ayncronous operations uses https://github.com/kriskowal/q so you'll need to make sure that all asyncronous functions/values you supply to the templates are 'thenables' so that they'll work with Q.  All that means in practice is that you need your promises to have a function `then` that you can call with a promise.\r\n\r\n## Installation\r\n\r\n    $ npm install qejs\r\n\r\n## Example\r\n\r\n    <% if (user) { %>\r\n        <h2><%= user.getNameAsync() %></h2>\r\n    <% } %>\r\n\r\n## Usage\r\n\r\n    qejs.compile(str, options);\r\n    // => Function\r\n\r\n    qejs.render(str, options);\r\n    // => promise\r\n\r\n    qejs.render(str, options).then(function(output){\r\n            //output is a string\r\n        });\r\n\r\n## Options\r\n\r\n  - `cache`           Compiled functions are cached, requires `filename`\r\n  - `filename`        Used by `cache` to key caches\r\n  - `scope`           Function execution context\r\n  - `debug`           Output generated function body\r\n  - `open`            Open tag, defaulting to \"<%\"\r\n  - `close`           Closing tag, defaulting to \"%>\"\r\n  - *                 All others are template-local variables\r\n\r\n## Custom tags\r\n\r\nCustom tags can also be applied globally:\r\n\r\n    var qejs = require('qejs');\r\n    qejs.open = '{{';\r\n    qejs.close = '}}';\r\n\r\nWhich would make the following a valid template:\r\n\r\n    <h1>{{= title }}</h1>\r\n\r\n## Unbuffered Code\r\n\r\n```\r\n<% code %>\r\n```\r\n\r\nQEJS supports exactly the same syntax as EJS for unbuffered code, usefull for conditionals, loops etc.\r\n\r\n## Escapes HTML\r\n\r\n```\r\n<%= code %>\r\n```\r\n\r\nThis differs from EJS in that if `code` returns a promise, it is resolved and then escaped before being outputted.  While this is happening, QEJS will continue on to render the rest of the template, allowing many promised functions to be executed in parallel.\r\n\r\n## Unescaped Buffering\r\n\r\n```\r\n<%- code %>\r\n```\r\n\r\nIf `code` isn't a promise, this will work exactly like EJS, but if `code` is a promise, we will resolve it, before outputting the resolved value.  We won't do any escaping on this value, so only use for trusted values, not user input.\r\n\r\n## Async Blocks\r\n\r\n```\r\n<% promise -> value %>...Use value here...<% <- %>\r\n<% PromiseForAnArray -> [valueA, valueB, valueC...] %>...Use values individually here...<% <- %>\r\n<% [promiseA,promiseB,promiseC...] -> values %>...Use identifier as an array of resolved values...<% <- %>\r\n<% [promiseA,promiseB,promiseC...] -> [valueA,valueB,valueC...] %>...Use values individually here...<% <- %>\r\n```\r\n\r\nAsync blocks are considered a relatively advanced feature, and where possible you should try and tick to just returning promises through `<%= code %>` as it's much easier to write that without creating bugs.\r\n\r\nHaving said that, async blocks are not difficult to write and I hope you'll end up really loving them for those times when you really need them.\r\n\r\nWhat happens in an async block is we reserve a space for whatever text is outputted by the block, allowing you to use any QEJS inside the async block (including another async block).  We then resolve the value of the promise you give us, and we give it the name you specify on the right hand side of the arrow operator.  The async block starter must go in its own separate unbuffered code block, but you could put other things like comments inside the block with the end marker.\r\n\r\nOnce you go past the end marker of an async block, you will no longer have access to the value of the promise.  This lets us run lots of calls in parallel, and means that you can use async blocks inside `if` statments, `for` statements, `while` statements, `function` statements, pretty much anywhere you could write regular EJS.\r\n\r\n## Inheritance and Partials\r\n\r\nQEJS supports both inheritance and partials.  Inheritance is used to include the current template in the middle of some other template (similar to express's layout templates except a little more powerful).  Currently this only works if you use the renderFile method (or render in express with the following snippet to setup).\r\n\r\n### Inheritance\r\n\r\nInheritance allows you to support features similar to those in express's layout template.  To use a layout for a template, simply call `inherits('relative/path/to/template')` anywhere in your template that is not run asyncronously.  That is to say, it can't go inside an async block, or inside the then callback of a promise.  Usually it's best to put it at the top of your file.  If you call it multiple times, it will throw an exception.\r\n\r\nviews/foobar.html\r\n\r\n```html\r\n<% inherits('layouts/navigation') %>\r\n<p>The great page foobar</p>\r\n```\r\n\r\nlayouts/navigation\r\n\r\n```html\r\n<% inherits('base') %>\r\n<a href=\"#home\">Home</a>\r\n<a href=\"#about\">About</a>\r\n<div class=\"content\">\r\n    <%- contents %>\r\n</div>\r\n```\r\n\r\nlayouts/base\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n        <title>Document</title>\r\n    </head>\r\n    <body>\r\n        <%- contents %>\r\n    </body>\r\n</html>\r\n```\r\n\r\nBe careful not to inherit from yourself as this would create errors that never got caught if you create an infinite loop of inheritance.\r\n\r\nAs you can see, paths are resolved in a very forgiving way.  They are resolved relative to the current file, then relative to the parent directory of the current directory and so on up the tree until a file is found.  It will try for files with extensions '.qejs', '.ejs' and '.html' in that order unless you specify an extension.\r\n\r\n### Partials\r\n\r\nYou can render a child template within the current template.  By default, it does not currently have access to any local variables of the calling template, only those supplied in options.\r\n\r\nTo use, simply call render anywhere in the parent template.\r\n\r\nlayouts/base\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n        <title>Document</title>\r\n    </head>\r\n    <body>\r\n        <%- render('views/foobar', {message:'hello world'}) %>\r\n    </body>\r\n</html>\r\n```\r\n\r\n```html\r\n<p><%= message %></p>\r\n```\r\n\r\n## Newline slurping\r\n\r\nIf you end any code block with a `-` even if it's an async block, we'll support newline slurping for you (`<% code -%>` or `<% -%>` or `<%= code -%>`, `<%- code -%>`, `<% promise -> result -%>` or `<% < -%>`)  That is to say, we won't output the next new line after we see that symbol.  QEJS never outputs a newline inside a code block.\r\n\r\n## Filters\r\n\r\nQEJS doesn't support filters.  Although in a way it seems a shame not to maintain 100% compatability with the syncronous form of EJS, I think that it's more important to keep this library lean.  Filters don't really add a lot, you can always attach such methods to arrays yourself and use standard javascript syntax, I don't want to hurt the purity of EJS though, so I've chosen not to add this syntax (bloat).\r\n\r\n## ExpressJS Integration\r\n\r\nThis module is fully compatible with [express 3.0.0](https://github.com/visionmedia/express) via the [consolidate.js](https://github.com/visionmedia/consolidate.js) library.\r\n\r\nTo use it you'll need to install both consolidate and QEJS.  You can do this in a single command with:\r\n\r\n    npm install consolidate qejs\r\n\r\nThe following example demonstrates using QEJS in express:\r\n\r\n```javascript\r\nvar express = require('express')\r\n  , cons = require('consolidate')\r\n  , app = express();\r\n\r\n// assign the swig engine to .html files\r\napp.engine('html', cons.qejs);\r\n\r\n// set .html as the default extension \r\napp.set('view engine', 'html');\r\napp.set('views', __dirname + '/views');\r\n\r\nvar users = [];\r\nusers.push({ name: 'tobi' });\r\nusers.push({ name: 'loki' });\r\nusers.push({ name: 'jane' });\r\n\r\napp.get('/', function(req, res){\r\n  res.render('index', {\r\n    title: 'Consolidate.js'\r\n  });\r\n});\r\n\r\napp.get('/users', function(req, res){\r\n  res.render('users', {\r\n    title: 'Users',\r\n    users: users\r\n  });\r\n});\r\n\r\napp.listen(3000);\r\nconsole.log('Express server listening on port 3000');\r\n```\r\n\r\nIf it doesn't work, be sure to make absolutely certain you've got the latest version of express, and make sure you have actually created a users.html and index.html view.\r\n\r\n## Contribute\r\n\r\nFork this repository to add features or:\r\n\r\n<a href=\"http://flattr.com/thing/699596/QEJS\" target=\"_blank\">\r\n<img src=\"http://api.flattr.com/button/flattr-badge-large.png\" alt=\"Flattr this\" title=\"Flattr this\" border=\"0\" /></a>\r\n\r\n## License \r\n\r\n  MIT\r\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/jepso/QEJS/issues"
  },
  "_id": "qejs@3.0.5",
  "dist": {
    "shasum": "22c408afc06b9ac00ef96b470502390fc19c62e9"
  },
  "_from": "qejs@",
  "_resolved": "https://registry.npmjs.org/qejs/-/qejs-3.0.5.tgz"
}
